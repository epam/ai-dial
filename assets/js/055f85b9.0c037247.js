"use strict";(self.webpackChunkdial=self.webpackChunkdial||[]).push([[9789],{11225:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/gcp-deployment-18bde3670b34bc20486b6854ba2418c4.svg"},28453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var t=n(96540);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}},88494:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tutorials/devops/deployment/gcp-deployment-guide","title":"GCP Deployment Guide","description":"Prerequisites","source":"@site/docs/tutorials/2.devops/0.deployment/4.gcp-deployment-guide.md","sourceDirName":"tutorials/2.devops/0.deployment","slug":"/tutorials/devops/deployment/gcp-deployment-guide","permalink":"/tutorials/devops/deployment/gcp-deployment-guide","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"CustomSideBar","previous":{"title":"Azure Deployment Guide","permalink":"/tutorials/devops/deployment/azure-deployment-guide"},"next":{"title":"AWS Deployment Guide","permalink":"/tutorials/devops/deployment/aws-deployment-guide"}}');var s=n(74848),r=n(28453);const o={},a="GCP Deployment Guide",d={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Scalability",id:"scalability",level:2},{value:"DIAL Services",id:"dial-services",level:3},{value:"Language Models",id:"language-models",level:3},{value:"High Availability",id:"high-availability",level:2},{value:"Disaster Recovery",id:"disaster-recovery",level:2},{value:"Support",id:"support",level:2}];function c(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"gcp-deployment-guide",children:"GCP Deployment Guide"})}),"\n",(0,s.jsx)(i.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(i.p,{children:"All cloud infrastructure services required for the DIAL deployment are shown in the diagram below:"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"mid-zoom",src:n(11225).A+"",width:"619",height:"1012"})}),"\n",(0,s.jsx)(i.p,{children:"The table summarizes GCP service configurations and tiers recommended for a production deployment. Lower environments may use less resilient configurations to save costs."}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"GCP Service"}),(0,s.jsx)(i.th,{children:"Configuration / Tier"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Google Kubernetes Engine (GKE)"}),(0,s.jsx)(i.td,{children:"Standard (regional cluster with zone redundancy)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Cloud Load Balancing (Global External HTTP(S))"}),(0,s.jsx)(i.td,{children:"Standard"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Cloud Storage"}),(0,s.jsx)(i.td,{children:"Standard storage (dual-region or multi-region)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Memorystore for Redis"}),(0,s.jsx)(i.td,{children:"Standard tier, HA configuration"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Vertex AI Platform"}),(0,s.jsx)(i.td,{children:"Depends on the capacity requirements and models (e.g., PaLM API, Gemini models) \u2013 usage-based pricing applies."})]})]})]}),"\n",(0,s.jsx)(i.p,{children:"There are a few dependencies, where the technology choice may depend on the corporate standards. The table below summarizes Google Cloud services that can be used to implement each of these dependencies if there is no specific corporate standard."}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Dependency"}),(0,s.jsx)(i.th,{children:"Azure Service"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"SSO"}),(0,s.jsx)(i.td,{children:"Cloud Identity"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Firewall"}),(0,s.jsx)(i.td,{children:"Cloud Armor (for WAF capabilities) integrated with Load Balancing, VPC firewall rules"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Logging and monitoring tools"}),(0,s.jsx)(i.td,{children:"Google Cloud Observability"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Container registry"}),(0,s.jsx)(i.td,{children:"Artifact Registry"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Secret Storage"}),(0,s.jsx)(i.td,{children:"Secret Manager"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"scalability",children:"Scalability"}),"\n",(0,s.jsx)(i.p,{children:"There are two sets of resources, each of which has its own recommended scaling approach: DIAL services and LLM models."}),"\n",(0,s.jsx)(i.h3,{id:"dial-services",children:"DIAL Services"}),"\n",(0,s.jsx)(i.p,{children:"DIAL services are stateless, so can have multiple copies running concurrently. As a baseline, a production deployment should have two copies of each service running on different nodes to achieve high availability of the solution. Usually there is no need to scale DIAL services further, because they are not resource-intensive and can handle an organization with thousands of DIAL users."}),"\n",(0,s.jsx)(i.p,{children:"However, to be resilient to load spikes, it is recommended to configure autoscaling for DIAL Core service so that more copies are run if the total CPU usage across all instances goes beyond a certain threshold for a certain duration (e.g. more 80% of the total CPU limit for 1 minute).\nApart from that, cluster autoscaling should be configured as well to add an extra node in case the already existing nodes do not have capacity to run a new copy of the DIAL Core service."}),"\n",(0,s.jsx)(i.h3,{id:"language-models",children:"Language Models"}),"\n",(0,s.jsx)(i.p,{children:"Scaling of LLM model instances is a common scenario for DIAL, because a single instance is usually not enough for an organization due to the model\u2019s request rate limits. With Vertex AI Platform service in GCP, there are four levels of scaling:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Increasing the number of model instances in the same region."}),"\n",(0,s.jsx)(i.li,{children:"Requesting a regional quota extension for a model - every region has a fixed quota for every model type in terms of tokens per minute (TPM). The sum of model instance capacities within the same region can\u2019t exceed this quota. If the current quota is not enough, in some cases it is possible to request the extension via the GCP Console."}),"\n",(0,s.jsx)(i.li,{children:"Deploying model instances in additional regions."}),"\n",(0,s.jsx)(i.li,{children:"Using multiple GCP projects to access model endpoints."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"It makes sense to use any approach from above only if the previous one doesn\u2019t help anymore."}),"\n",(0,s.jsx)(i.h2,{id:"high-availability",children:"High Availability"}),"\n",(0,s.jsx)(i.p,{children:"High availability is achieved through leveraging the platform's regional and multi-zone capabilities:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Running multiple copies of DIAL services in different availability zones by utilizing a multi-zone GKE cluster."}),"\n",(0,s.jsx)(i.li,{children:"Using highly available configurations of other GCP services."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Here is a reference list of availability SLA metrics for the GCP services used in the solution."}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Service"}),(0,s.jsx)(i.th,{children:"Availability SLA"}),(0,s.jsx)(i.th,{children:"Resilient to zone-wide outages"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Google Kubernetes Engine (GKE)"}),(0,s.jsx)(i.td,{children:"99.95% if deployed with zone redundancy, otherwise 99.5%"}),(0,s.jsx)(i.td,{children:"Yes, if configured explicitly"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Cloud Identity"}),(0,s.jsx)(i.td,{children:"99.9% - 99.99%"}),(0,s.jsx)(i.td,{children:"Yes"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Cloud Storage"}),(0,s.jsx)(i.td,{children:"99.95% if using dual-region or multi-region location, otherwise 99.9%"}),(0,s.jsx)(i.td,{children:"Yes"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Memorystore for Redis"}),(0,s.jsx)(i.td,{children:"99.9% if deployed with zone redundancy"}),(0,s.jsx)(i.td,{children:"Yes, if configured explicitly"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Vertex AI Platform"}),(0,s.jsx)(i.td,{children:"99.5% - 99.9%"}),(0,s.jsx)(i.td,{children:"Depends on configuration (model type, deployment across zones)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Secret Manager"}),(0,s.jsx)(i.td,{children:"99.95%"}),(0,s.jsx)(i.td,{children:"Yes"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Artifact Registry"}),(0,s.jsx)(i.td,{children:"99.95%"}),(0,s.jsx)(i.td,{children:"Yes (Regional)"})]})]})]}),"\n",(0,s.jsx)(i.p,{children:"Vertex AI services provide an SLA of up to 99.9%, ensuring high availability and reliability for your AI workloads. To improve resilience beyond the SLA, it is worth having multiple endpoints in different regions. If one region becomes unavailable, DIAL can automatically switch to another endpoint, ensuring the service keeps running smoothly."}),"\n",(0,s.jsx)(i.h2,{id:"disaster-recovery",children:"Disaster Recovery"}),"\n",(0,s.jsxs)(i.p,{children:["There are two pieces of the DIAL solution: ",(0,s.jsx)(i.a,{href:"/platform/architecture-and-concepts/components#dial-core",children:"DIAL Core"})," and ",(0,s.jsx)(i.a,{href:"/platform/architecture-and-concepts/components#analytics-realtime",children:"DIAL Analytics"}),". Since DIAL Analytics is an optional component that can be managed separately from the Core, it is better to separate disaster recovery policies for both."]}),"\n",(0,s.jsx)(i.p,{children:"The Core part consists of a set of stateless services and a single permanent storage based on GCP Cloud Storage (Memorystore for Redis in this case is treated as stateless, because it serves only as a cache for the primary storage and can be safely restarted if necessary). In case of a region-wide failure, the entire set of components must be run in a different region:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"GCP Cloud Storage \u2013 since it uses dual-region or multi-region configurations, Cloud Storage provides built-in redundancy and availability across regions. For disaster recovery, accessing data from the secondary region is automatic or can involve failover procedures depending on the exact setup. To maintain multi-region redundancy after a regional failure, the configuration may need to be reviewed and potentially re-established."}),"\n",(0,s.jsx)(i.li,{children:"All other services \u2013 since they are stateless, the entire set of services can be deployed in the secondary region from scratch and the DIAL instance domain name re-routed to the new entry point. Depending on the RTO requirement, this step can be sped up by having a passive instance of DIAL Core always deployed in the secondary region and activated in case of a failure."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"support",children:"Support"}),"\n",(0,s.jsx)(i.p,{children:"It is recommended to configure monitoring and alerts to manage the DIAL deployment. To seamlessly host DIAL in diverse enterprise environments, it provides standard interfaces for logs and metrics collection via OpenTelemetry interfaces.\nSpecific tools used for logging, monitoring and alerting purposes depend on the corporate standards of each customer."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);