"use strict";(globalThis.webpackChunkdial=globalThis.webpackChunkdial||[]).push([[628],{84162(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"tutorials/developers/prompt-caching","title":"Prompt Caching","description":"About Prompt Caching","source":"@site/docs/tutorials/1.developers/6.prompt-caching.md","sourceDirName":"tutorials/1.developers","slug":"/tutorials/developers/prompt-caching","permalink":"/tutorials/developers/prompt-caching","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"CustomSideBar","previous":{"title":"Integration with n8n","permalink":"/tutorials/developers/integrations/n8n-integration"},"next":{"title":"Custom Apps Deployment","permalink":"/tutorials/devops/deployment/custom_apps_deployment"}}');var s=n(74848),r=n(28453);const a={},o="Prompt Caching",c={},l=[{value:"About Prompt Caching",id:"about-prompt-caching",level:2},{value:"Prompt Caching in LLM",id:"prompt-caching-in-llm",level:2},{value:"Prompt Caching in DIAL",id:"prompt-caching-in-dial",level:2},{value:"Cache-Availability Priority Policy",id:"cache-availability-priority-policy",level:3},{value:"Types of Prompt Caching",id:"types-of-prompt-caching",level:3},{value:"Automatic",id:"automatic",level:4},{value:"Deployment configuration",id:"deployment-configuration",level:5},{value:"Manual",id:"manual",level:4},{value:"Deployment configuration",id:"deployment-configuration-1",level:5},{value:"Cache breakpoint",id:"cache-breakpoint",level:5}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"prompt-caching",children:"Prompt Caching"})}),"\n",(0,s.jsx)(t.h2,{id:"about-prompt-caching",children:"About Prompt Caching"}),"\n",(0,s.jsx)(t.p,{children:"Prompt caching, also referred to as context caching, is a technique used to optimize performance and reduce the operational costs of interacting with large language models (LLMs)."}),"\n",(0,s.jsx)(t.p,{children:"By storing and reusing previously processed data, prompt caching eliminates the need to reprocess the same information in subsequent requests. This approach is particularly beneficial in scenarios such as multi-turn conversations, complex workflows, or applications requiring repetitive queries, where parts of the request (e.g., system instructions, user prompts, or tool definitions) remain unchanged."}),"\n",(0,s.jsx)(t.p,{children:"By leveraging cached data, systems can significantly reduce computation time, improve response efficiency, and lower token usage costs, making it an essential feature for scalable and cost-effective AI implementations."}),"\n",(0,s.jsx)(t.h2,{id:"prompt-caching-in-llm",children:"Prompt Caching in LLM"}),"\n",(0,s.jsx)(t.p,{children:"Large Language Models (LLMs) process sequences of input tokens and generate sequences of output tokens. Each token consumed modifies the internal state of the LLM in a predictable manner. Once all input tokens are processed, the model begins generating output tokens one by one."}),"\n",(0,s.jsx)(t.p,{children:"Prompt caching leverages the predictable state changes in LLMs to optimize processing for input sequences that share the same prefix. For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"input sequence 1: [tokenA, tokenB, tokenC, tokenD, ...]\ninput sequence 2: [tokenA, tokenB, tokenC, tokenE, ...]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["To optimize these sequences: Roll the LLM through the first sequence until the shared prefix ends (e.g., ",(0,s.jsx)(t.code,{children:"[tokenA, tokenB, tokenC]"}),"), save the model's state after processing the shared prefix, begin processing the second sequence from this precomputed state, skipping redundant computations for the shared prefix."]}),"\n",(0,s.jsx)(t.p,{children:"End users of LLMs rarely deal with streams of input tokens directly. Instead, a high-level concept of a chat request is used more commonly.\nThe idea of prompt caching translates from tokens to chat requests fairy easily - adjacent parts of the chat request (such as tool definitions and messages) eventually map onto adjacent blocks of input tokens which are fed into the LLM. Therefore, we can relate prompt caching to a sequence of tool definitions and chat messages in chat completion requests. Requests starting with the same sequence of tools/messages can be computed more efficiently thanks to the prompt caching."}),"\n",(0,s.jsxs)(t.p,{children:["Leading model providers such as ",(0,s.jsx)(t.a,{href:"https://platform.openai.com/docs/guides/prompt-caching",children:"OpenAI"}),", ",(0,s.jsx)(t.a,{href:"https://ai.google.dev/gemini-api/docs/caching?lang=python",children:"Google"}),", and ",(0,s.jsx)(t.a,{href:"https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-caching.html",children:"AWS"})," support prompt caching. However, all of them limit the caching scope to a single endpoint. Meaning that in order to leverage caching, the requests sharing the same prefixes must be sent to the same model deployment."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"/platform/core/about-core",children:"DIAL Core"})," can automate this process, ensuring that requests with shared prefixes are routed to the same model deployment."]}),"\n",(0,s.jsx)(t.h2,{id:"prompt-caching-in-dial",children:"Prompt Caching in DIAL"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"/platform/core/about-core",children:"DIAL Core"})," uses hashing to redirect chat completion requests with the same prefix to the same upstream endpoint:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Unique hashes are computed for each prefix of an incoming ",(0,s.jsx)(t.a,{href:"https://dialx.ai/dial_api#operation/sendChatCompletionRequest",children:"chat completion request"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"The mapping from the hashes to an upstream endpoint and expiration time is saved to Redis cache."}),"\n",(0,s.jsx)(t.li,{children:"When next request comes in, DIAL Core computes the hashes again and looks them up in the mapping. When there is a match, it sends the request to the corresponding upstream endpoint."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"cache-availability-priority-policy",children:"Cache-Availability Priority Policy"}),"\n",(0,s.jsx)(t.p,{children:"When DIAL Core finds a matching hash in the Redis cache and routes the request to the corresponding upstream, it may encounter an error in the response. This raises the question:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Should DIAL Core retry the request to the same upstream (potentially resulting in a cache hit)?"}),"\n",(0,s.jsx)(t.li,{children:"Or should it route the request to another upstream (guaranteeing a cache miss but ensuring service availability)?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"By default, DIAL Core prioritizes service availability. If the upstream associated with the cache is unavailable or returns an error, the request is routed to another upstream, even though this guarantees a cache miss."}),"\n",(0,s.jsxs)(t.p,{children:["This behavior can be customized using the ",(0,s.jsx)(t.code,{children:"X-CACHE-POLICY"})," header in the ",(0,s.jsx)(t.a,{href:"https://dialx.ai/dial_api#operation/sendChatCompletionRequest",children:"chat completion request"}),". The two available policies are:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"availability-priority"})," (default):","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Prioritizes service availability over cache hits."}),"\n",(0,s.jsx)(t.li,{children:"If the cache upstream is unavailable or returns an error, the request is routed to another upstream."}),"\n",(0,s.jsx)(t.li,{children:"Ensures the request succeeds but sacrifices cached efficiency."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"cache-priority"}),":","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Prioritizes cache hits over availability."}),"\n",(0,s.jsx)(t.li,{children:"Retries the request on the same upstream, even if the upstream initially returned an error."}),"\n",(0,s.jsx)(t.li,{children:"Maximizes the chances of leveraging cached data but risks delayed responses if the upstream remains unavailable."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"types-of-prompt-caching",children:"Types of Prompt Caching"}),"\n",(0,s.jsxs)(t.p,{children:["DIAL supports two types of prompt caching: ",(0,s.jsx)(t.a,{href:"#automatic",children:"automatic"})," and ",(0,s.jsx)(t.a,{href:"#manual",children:"manual"}),". The following table summarizes pros and cons of these types of caching."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"}}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Automatic Caching"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Manual Caching"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"User Effort"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Minimal (handled by the system)"}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["High (users must explicitly mark ",(0,s.jsx)(t.a,{href:"#cache-breakpoint",children:"cache breakpoints"}),")"]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Control"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Limited (system decides breakpoints)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Full (users decide breakpoints)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Use Case"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Multi-turn conversations, general efficiency"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Custom workflows, advanced use cases"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Dependency on Provider"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Depends on automatic caching support from the provider (e.g., OpenAI)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Works as long as the provider supports caching"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Flexibility"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Low (system-driven)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"High (user-driven)"})]})]})]}),"\n",(0,s.jsx)(t.h4,{id:"automatic",children:"Automatic"}),"\n",(0,s.jsx)(t.p,{children:"Automatic caching happens without explicit user input. The system determines when and where to create cache entries, making it seamless for the user. This is ideal for multi-turn conversations where only new content needs to be processed, while cached content is reused."}),"\n",(0,s.jsx)(t.h5,{id:"deployment-configuration",children:"Deployment configuration"}),"\n",(0,s.jsxs)(t.p,{children:["Enable automatic caching by setting the ",(0,s.jsx)(t.a,{href:"https://github.com/epam/ai-dial-core?tab=readme-ov-file#dynamic-settings",children:"deployment feature flag"})," ",(0,s.jsx)(t.code,{children:"autoCachingSupported"})," to ",(0,s.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"IMPORTANT"}),": Ensure the language model supports automatic prompt caching before enabling it. Not all models support this feature."]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"manual",children:"Manual"}),"\n",(0,s.jsx)(t.p,{children:"Manual Caching is ideal for scenarios that require a precise control over what parts of a request are cached, especially in complex workflows."}),"\n",(0,s.jsx)(t.p,{children:"You have full control over where cache breakpoints are placed, making it suitable for highly customized workflows. For example, working with a complex prompt (e.g., a mix of tool definitions, system instructions, and user messages) you can explicitly mark parts of the request for caching to optimize performance."}),"\n",(0,s.jsx)(t.h5,{id:"deployment-configuration-1",children:"Deployment configuration"}),"\n",(0,s.jsxs)(t.p,{children:["Enable manual caching by setting the ",(0,s.jsx)(t.a,{href:"https://github.com/epam/ai-dial-core?tab=readme-ov-file#dynamic-settings",children:"deployment feature flag"})," ",(0,s.jsx)(t.code,{children:"cacheSupported"})," to ",(0,s.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"IMPORTANT"}),": Ensure the language model supports prompt caching before enabling it. Not all models support this feature."]}),"\n"]}),"\n",(0,s.jsx)(t.h5,{id:"cache-breakpoint",children:"Cache breakpoint"}),"\n",(0,s.jsxs)(t.p,{children:["In this type of prompt caching, you manually mark parts of chat completion request with ",(0,s.jsx)(t.strong,{children:"cache breakpoints"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"DIAL Core computes hashes only for request prefixes ending with a cache breakpoint."}),"\n",(0,s.jsxs)(t.p,{children:["Tool definitions and chat messages can be marked with cache breakpoints using the ",(0,s.jsx)(t.code,{children:"custom_fields.cache_breakpoint"})," field.\nBreakpoints can include an ",(0,s.jsx)(t.code,{children:"expire_at"})," field to set a time-to-live (TTL) for the corresponding cache entry in DIAL Core and on the LLM side."]}),"\n",(0,s.jsx)(t.p,{children:"Example of cache breakpoints in a chat completion request:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n    "tools": [\n        {\n            "type": "function",\n            "name": "query_db",\n            "parameters": {},\n            "custom_fields": {\n                "cache_breakpoint": {}\n            }\n        }\n    ],\n    "messages": [\n        {\n            "role": "system",\n            "content": "(long instructions)",\n            "custom_fields": {\n                "cache_breakpoint": {\n                    "expire_at": "2014-10-02T15:01:23Z"\n                }\n            }\n        },\n        {\n            "role": "user",\n            "content": "(query)"\n        }\n    ]\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453(e,t,n){n.d(t,{R:()=>a,x:()=>o});var i=n(96540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);